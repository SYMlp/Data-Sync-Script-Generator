# 主从表同步脚本生成工具平台需求文档

# 一、文档概述

## 1.1 文档目的

本文档明确“主从表同步脚本生成工具平台”（以下简称“工具平台”）的功能需求、非功能需求、实施步骤及实例说明，作为开发工作的核心依据，确保开发成果契合“简单执行”“高度复用”“配置驱动”的核心目标。

## 1.2 核心背景

现有主从表（1:N关系）数据同步依赖人工编写SQL事务脚本，存在以下问题：

- 重复劳动：不同业务场景的主从表同步逻辑一致，但需重复编写表名、字段等冗余代码；

- 易出错：人工拼接字段、SQL语法易遗漏，且难以保证事务原子性；

- 复用性差：脚本与具体表强绑定，新表同步需重新开发；

- 现场执行复杂：需携带定制化脚本，适配不同环境效率低。

工具平台旨在通过“元数据自动获取+规则配置+脚本自动生成”的方式，解决上述问题，输出可直接在项目现场执行的纯SQL事务脚本。

## 1.3 核心目标

1. 简单性：生成的脚本无需依赖外部应用，仅通过MySQL客户端即可执行；

2. 复用性：一套工具适配所有1:N主从表同步场景，通过配置切换业务对象；

3. 准确性：自动获取表结构，避免人工编写字段、关联规则的错误；

4. 安全性：生成的脚本内置事务保障，同步失败自动回滚。

# 二、核心需求

## 2.1 核心业务逻辑

工具平台核心流程：**连接数据库获取元数据 → 用户配置同步规则 → 自动生成事务脚本 → 脚本导出/直接执行**，核心约束为“仅支持MySQL数据库、仅处理1:N主从表同步场景”。

## 2.2 功能需求（分模块）

### 模块1：元数据管理模块——自动获取库表信息

核心功能：通过API连接MySQL数据库，自动获取同步所需的表结构、字段属性等元数据，避免人工录入。

#### 2.2.1 功能点1：数据库连接配置

操作步骤及实例：

1. 用户输入连接参数，界面表单如下：
        配置项说明实例数据库类型固定为MySQLMySQL 8.0IP地址数据库服务地址192.168.1.100端口数据库服务端口3306用户名具备查询权限的账号（需访问information_schema）sync_user密码对应账号密码*******数据库名源库/目标库的具体库名（支持分别配置）源库：db_source；目标库：db_target

2. 工具验证连接有效性，失败则提示“IP错误/权限不足”等具体原因。

#### 2.2.2 功能点2：表结构自动查询

操作步骤及实例：

1. 连接成功后，工具自动加载对应数据库下的所有表名，用户可通过搜索筛选目标表；

2. 用户选择表后，工具执行以下SQL查询元数据（内置逻辑，无需人工操作）：
        `-- 1. 查询表字段信息（含类型、主键、是否自增）
SELECT 
  column_name AS 字段名,
  data_type AS 字段类型,
  CASE WHEN column_key = 'PRI' THEN 1 ELSE 0 END AS 是否主键,
  CASE WHEN extra LIKE '%auto_increment%' THEN 1 ELSE 0 END AS 是否自增,
  column_comment AS 字段注释
FROM information_schema.columns 
WHERE table_schema = 'db_source'  -- 动态替换为用户配置的库名
  AND table_name = 't_kl_service_instance';  -- 动态替换为用户选择的表名

-- 2. 查询表注释
SELECT table_comment FROM information_schema.tables 
WHERE table_schema = 'db_source' 
  AND table_name = 't_kl_service_instance';`

3. 工具将查询结果以表格形式展示，示例如下：
        字段名字段类型是否主键是否自增字段注释idint11主键service_namevarchar(255)00服务名称（唯一标识）service_typevarchar(20)00服务类型

### 模块2：同步规则配置模块——可视化定义核心规则

核心功能：用户通过可视化界面配置同步所需的核心规则，替代硬编码，实现“配置即业务”的复用目标。

#### 2.2.3 功能点1：主从表关系配置

操作步骤及实例：

1. 用户选择“1:N主从表”模式，工具展示表关系配置表单，支持配置1组源主从表、1组目标主从表；

2. 配置示例：
        配置项说明实例源主表从元数据列表中选择db_source.t_kl_service_instance源从表从元数据列表中选择，与源主表为1:N关系db_source.t_kl_service_instance_property目标主表从元数据列表中选择（需与源主表结构兼容）db_target.t_kl_service_instance目标从表从元数据列表中选择（需与源从表结构兼容）db_target.t_kl_service_instance_property

3. 工具自动校验：源主从表、目标主从表的字段结构是否匹配（字段名、类型一致，主键规则一致），不匹配则提示“目标主表缺少service_type字段”等具体问题。

#### 2.2.4 功能点2：同步依据配置

操作步骤及实例：

1. 用户配置主表同步唯一标识、从表关联规则，配置项如下：
        配置项说明实例主表唯一标识字段源主表中用于匹配目标主表的唯一字段（非主键，如名称）service_name（服务名称唯一）主从表关联字段从表中关联主表主键的字段（源/目标从表此字段需一致）service_id（从表通过该字段关联主表id）从表唯一标识字段同主表下，从表记录的唯一标识（用于匹配目标从表）param（同service_id下，参数名唯一）

2. 工具自动校验：配置的字段是否存在于对应表中、是否符合唯一约束（如主表唯一标识字段需在源主表中有唯一索引）。

#### 2.2.5 功能点3：同步范围与例外配置

操作步骤及实例：

1. 同步范围配置：用户输入SQL过滤条件，定义需同步的源表数据，工具提供语法提示：
        配置项说明实例源表过滤条件仅同步符合条件的源表数据（WHERE子句内容）is_del = 0 AND tenant_id = 1001（未删除且租户为1001）

2. 例外字段配置：用户从主从表字段列表中勾选“不同步字段”（如保留目标表的创建时间），示例：
        表类型不同步字段（勾选）原因目标主表create_time、create_user保留目标表原始创建信息目标从表create_time、create_user保留目标表原始创建信息

### 模块3：脚本生成模块——自动生成可执行事务脚本

核心功能：根据元数据和同步规则，自动生成纯SQL事务脚本（存储过程形式），确保脚本包含事务保障、字段自动填充、逻辑完整。

#### 2.2.6 功能点1：脚本自动生成逻辑

生成步骤（工具内置逻辑，无需人工干预）：

1. 脚本结构拼接：固定事务框架（START TRANSACTION/COMMIT/ROLLBACK）+ 动态填充表名、字段、条件；

2. 字段自动筛选：从元数据中排除“主键（自增）”“不同步字段”，生成INSERT/UPDATE的字段列表；

3. 关联逻辑拼接：根据“主从表关联字段”“唯一标识字段”，自动生成主表匹配、从表关联的SQL逻辑；

4. 注释自动添加：脚本中包含配置信息（如“同步规则：主表唯一标识service_name”）、逻辑说明（如“主表更新：用源表覆盖目标表”）。

#### 2.2.7 功能点2：生成脚本实例（核心片段）

工具根据上述配置生成的脚本（可直接执行）：

```sql

DELIMITER $$

-- 同步规则说明：
-- 源主从表：db_source.t_kl_service_instance → db_source.t_kl_service_instance_property
-- 目标主从表：db_target.t_kl_service_instance → db_target.t_kl_service_instance_property
-- 主表唯一标识：service_name；主从关联字段：service_id；从表唯一标识：param
-- 过滤条件：is_del = 0 AND tenant_id = 1001
CREATE PROCEDURE SyncServiceAndPropertyData()
BEGIN
    -- 声明变量（工具自动生成，关联配置的表字段）
    DECLARE done INT DEFAULT 0;
    DECLARE src_main_id INT; -- 源主表主键（id）
    DECLARE src_service_name VARCHAR(255); -- 主表唯一标识（service_name）
    DECLARE dest_main_id INT; -- 目标主表主键
    
    -- 游标：查询源主表符合条件的数据（工具自动填充过滤条件）
    DECLARE main_cursor CURSOR FOR
        SELECT id, service_name 
        FROM db_source.t_kl_service_instance
        WHERE is_del = 0 AND tenant_id = 1001;
    
    -- 事务异常处理（固定逻辑）
    DECLARE EXIT HANDLER FOR SQLEXCEPTION
    BEGIN
        ROLLBACK;
        SELECT '同步失败，已回滚' AS result;
    END;

    START TRANSACTION;

    -- 主表同步：工具自动填充字段列表（排除id、create_time等）
    OPEN main_cursor;
    main_loop: LOOP
        FETCH main_cursor INTO src_main_id, src_service_name;
        IF done = 1 THEN LEAVE main_loop; END IF;

        -- 1. 匹配目标主表（通过service_name）
        SELECT id INTO dest_main_id
        FROM db_target.t_kl_service_instance
        WHERE service_name = src_service_name AND is_del = 0;

        -- 2. 主表更新/插入（工具自动填充字段，排除不同步字段）
        IF dest_main_id IS NOT NULL THEN
            UPDATE db_target.t_kl_service_instance dest
            INNER JOIN db_source.t_kl_service_instance src ON src.id = src_main_id
            SET 
                dest.service_identifier = src.service_identifier,
                dest.service_name = src.service_name,
                dest.resource_id = src.resource_id,
                dest.data_source_id = src.data_source_id,
                -- 工具自动生成剩余字段（排除create_time、create_user）
                dest.update_user = src.update_user,
                dest.update_time = src.update_time
            WHERE dest.id = dest_main_id;
        ELSE
            -- 插入新记录（工具自动生成字段列表）
            INSERT INTO db_target.t_kl_service_instance (
                service_identifier, service_name, resource_id, data_source_id,
                update_user, update_time, is_del
            )
            SELECT 
                service_identifier, service_name, resource_id, data_source_id,
                update_user, update_time, is_del
            FROM db_source.t_kl_service_instance 
            WHERE id = src_main_id;
            SET dest_main_id = LAST_INSERT_ID();
        END IF;

        -- 3. 从表同步（工具自动生成，关联dest_main_id）
        -- （从表更新/插入/删除逻辑，与主表逻辑一致，字段自动填充）
        -- ...（工具自动生成完整从表同步代码）

    END LOOP main_loop;
    CLOSE main_cursor;

    COMMIT;
    SELECT '同步成功' AS result;
END $$

DELIMITER ;

-- 执行同步
CALL SyncServiceAndPropertyData();
```

### 模块4：脚本管理模块——导出与执行

#### 2.2.8 功能点1：脚本导出

工具支持将生成的脚本以“.sql”文件格式导出，文件名自动命名为“同步_源主表_目标主表_时间戳.sql”，如“同步_t_kl_service_instance_t_kl_service_instance_20251119.sql”。

#### 2.2.9 功能点2：脚本执行

工具内置SQL执行功能：用户确认脚本后，可直接点击“执行”按钮，工具通过已配置的数据库连接执行脚本，并返回执行结果（“同步成功”/失败原因）。

## 2.3 非功能需求

|需求类型|具体要求|说明|
|---|---|---|
|兼容性|支持MySQL 5.7及以上版本|适配主流MySQL环境，通过版本检测适配语法差异|
|性能|单表10万条数据生成脚本时间≤3秒，执行效率与手工脚本一致|元数据查询采用索引优化，脚本生成逻辑异步处理|
|易用性|操作步骤≤5步，配置错误提示明确（如“字段不存在”）|界面采用向导式流程，每步配置有示例说明|
|安全性|数据库密码加密存储，脚本执行前需二次确认|避免密码泄露，防止误操作导致的数据覆盖|
# 三、实施步骤（开发阶段划分）

1. **阶段1：基础能力开发（1-2周）**开发数据库连接模块（支持MySQL，含连接校验）；

2. 开发元数据查询模块（获取表列表、字段信息，支持筛选）。

3. **阶段2：核心规则配置开发（1-2周）**开发主从表关系配置界面及校验逻辑；

4. 开发同步依据、过滤条件、例外字段配置模块。

5. **阶段3：脚本生成核心开发（2周）**开发SQL脚本模板（事务框架、游标逻辑等固定部分）；

6. 开发动态填充逻辑（表名、字段、条件等从配置中获取）；

7. 开发脚本注释自动生成功能。

8. **阶段4：脚本管理与测试（1周）**开发脚本导出、执行功能；

9. 用服务表、测试表进行多场景测试（如主表无匹配记录、从表冗余数据等）。

# 四、关键约束与注意事项

- 仅支持1:N主从表同步，暂不支持多主多从、N:M关联场景；

- 源表与目标表需结构兼容（字段名、类型一致，差异字段需在例外配置中排除）；

- 主表唯一标识字段需在源表和目标表中具备唯一约束（否则可能导致多记录匹配）；

- 现场执行脚本时，目标库账号需具备“增删改”权限，源库账号需具备“查询”权限。

# 五、验收标准

1. 配置3组不同主从表（服务表、用户表、订单表），工具均能正常生成脚本；

2. 生成的脚本执行后，目标表数据与源表一致（例外字段保留目标值，关联关系正确）；

3. 同步过程中人为制造错误（如字段值超长），脚本自动回滚，无数据残留；

4. 10万条数据的主从表同步，脚本执行时间≤5分钟，无性能问题。
> （注：文档部分内容可能由 AI 生成）